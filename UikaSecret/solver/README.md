# Uika's Secret 🕸️
> Author: 堇姬Naup

## Encrypt Way
Compared to traditional RSA, which is defined in $\mathbb{Z}_n$.
We use 2x2 Matrix to perform RSA operations.

First, we define $n = pq$ ， $p、q$ are prime numbers.
$g_p = |\text{GL}_2(\mathbb{Z}_p)| = (p^2-1)(p^2-p)$
$g_q = |\text{GL}_2(\mathbb{Z}_q)| = (q^2-1)(q^2-q)$
$g = g_p * g_q$

As in RSA, we choose positive integers $e, d \in \mathbb{Z}^+$ such that $ed \equiv 1 \pmod g$

The encryption and decryption processes are defined as follows:
- ENC: $M^e \equiv C \pmod n$
- DEC: $C^d \equiv M \pmod n$

## Proof
To prove that decryption works, we need to show:
$C^d \equiv M \pmod n$

Since we know that
$M^e \equiv C \pmod n$
substituting this into the decryption equation gives
$C^d \equiv  M^{ed} \pmod n$

Additionally, we have $ed \equiv 1 \equiv 1+kg \pmod g$
This allows us to rewrite: $M^{ed} \equiv M^{1+kg} \pmod n$

Now, we analyze the equation modulo p and modulo q separately.
$M^{(1 + k \cdot g)} \equiv M \cdot M^{g_p \cdot g_q \cdot k} \pmod{p}$

By Lagrange’s Theorem, we know the order $x$ of the cyclic subgroup generated by $M$ must divide $g_p$
such that $g_p = jx,j \in Z$

> Lagrange’s Theorem: G is a finite group and H is a subgroup of G , then the order of H must divide the order of G.

Substituting this into the equation: $M^{(1 + k \cdot g)} \equiv M \cdot M^{g_p \cdot g_q \cdot k} \equiv M \cdot M^{xj \cdot g_q \cdot k} \equiv M \cdot I^{j \cdot g_q \cdot k} \equiv M \pmod{p}$

Following the same reasoning mod q 
By CRT, we can get $C^d \equiv M \pmod n$

Completed the proof.

Basically, you can think of it as a generalization of Fermat's Little Theorem.
In short, when we know $p,q$, we can similarly compute $q=(p^2-p)(p^2-1)(q^2-q)(q^2-1), ed \equiv 1 \pmod q$ and find the private key $d$
We will get flag

## exploit
```py
import numpy as np
from sympy import Matrix, mod_inverse, nextprime
import random
from Crypto.Util.number import bytes_to_long, long_to_bytes

def matrix_pow_mod(M, exp, mod):
    res = Matrix.eye(M.shape[0])
    base = M % mod

    while exp > 0:
        if exp % 2 == 1:
            res = (res * base) % mod
        base = (base * base) % mod
        exp //= 2

    return res

p =  61663355624961617190932040364570122811
q =  164760119974434401898814698475465724393
e =  241
n =  10159661870794890476293793179851831470327420502145390407965725332377088428723
C =  Matrix([[710971571925534921766264001453800447832004011741471582271017297595284545063, 3524999238833012467859995354361760350244698137646388549155688288072972275956], [4401120047991683426513480120375140905980827474752990528860408308008937766492, 1790814478599722908002020939971717296632791919339844665095281340912463116991]])

gp = (p**2 - p) * (p**2 - 1)
gq = (q**2 - q) * (q**2 - 1)

g = gp * gq
d = mod_inverse(e, g)

print("Decryption exponent (d):", d)

result = matrix_pow_mod(C, d, n) 
print("Decrypted Matrix (M):")
print(result)

flag = b''
for i in result.tolist():
    for j in i:
        flag+=long_to_bytes(j)

print(flag)
```
